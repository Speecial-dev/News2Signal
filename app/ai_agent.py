import os
from typing import List, Dict, Any
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain.agents import AgentExecutor, create_openai_tools_agent
from langchain.tools import BaseTool
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.schema import BaseMessage, HumanMessage, AIMessage
from langchain.memory import ConversationBufferMemory
from langchain.tools import tool

from pydantic import BaseModel, Field
import asyncio
from langchain_community.chat_models import ChatOpenAI

load_dotenv()

# OpenAI API Key kontrol√º
OPENAI_API_KEY = os.getenv("TOGETHER_API_KEY")
if not OPENAI_API_KEY:
    raise ValueError("OPENAI_API_KEY environment variable is required")


class NewsToolInput(BaseModel):
    topic: str = Field(
        description="Analiz edilecek finansal konu (√∂rn: Bitcoin, Ethereum, Apple)"
    )


class SentimentToolInput(BaseModel):
    news_data: List[Dict] = Field(description="Analiz edilecek haber listesi")


class DecisionToolInput(BaseModel):
    sentiments: List[Dict] = Field(description="Sentiment analizi sonu√ßlarƒ±")


class TradingToolInput(BaseModel):
    symbol: str = Field(description="ƒ∞≈ülem yapƒ±lacak sembol (√∂rn: BTC, ETH)")
    decision: str = Field(description="ƒ∞≈ülem kararƒ± (buy, sell, hold)")
    amount: float = Field(description="ƒ∞≈ülem miktarƒ±", default=0.001)


class PlottingToolInput(BaseModel):
    topic: str = Field(description="Grafik konusu")
    sentiments: List[Dict] = Field(description="Sentiment verileri")


class FinancialAgent:
    def __init__(self):
        # OpenAI LLM

        self.llm = ChatOpenAI(
            model="mistralai/Mixtral-8x7B-Instruct-v0.1",  # √ñnerilen Together modeli
            temperature=0.1,
            openai_api_key=os.getenv("TOGETHER_API_KEY"),
            openai_api_base="https://api.together.xyz/v1",
        )

        # Memory
        self.memory = ConversationBufferMemory(
            memory_key="chat_history", return_messages=True
        )

        # Tools
        self.tools = [
            self.news_tool,
            self.sentiment_tool,
            self.decision_tool,
            self.trading_tool,
            self.plotting_tool,
        ]

        # Agent prompt
        self.prompt = ChatPromptTemplate.from_messages(
            [
                (
                    "system",
                    """Sen News2Signal, geli≈ümi≈ü bir finansal analiz AI agentƒ±sƒ±n. 
            
G√∂revin:
1. Kullanƒ±cƒ±nƒ±n finansal analiz isteklerini anla
2. Gerekli ara√ßlarƒ± kullanarak analiz yap
3. Akƒ±llƒ± kararlar ver ve a√ßƒ±kla
4. Kullanƒ±cƒ±ya yardƒ±mcƒ± ol

Kullanabileceƒüin ara√ßlar:
- news_tool: G√ºncel haberleri topla
- sentiment_tool: Haberlerin duygu analizini yap
- decision_tool: Sentiment skorlarƒ±na g√∂re karar ver
- trading_tool: Otomatik i≈ülem yap (sadece y√ºksek g√ºvenle)
- plotting_tool: Sentiment grafiƒüi olu≈ütur

√ñnemli kurallar:
- Finansal analiz isteklerinde MUTLAKA haber topla ve sentiment analizi yap
- Haber toplama ve sentiment analizi sonu√ßlarƒ±nƒ± detaylƒ± a√ßƒ±kla
- Her haberin sentiment skorunu ve gerek√ßesini belirt
- Trading i≈ülemlerini sadece y√ºksek g√ºven seviyesinde yap
- Selamla≈üma ve genel sohbet i√ßin ara√ß kullanma

√ñrnek i≈ü akƒ±≈üƒ±:
1. Kullanƒ±cƒ± "Bitcoin analiz et" dediƒüinde
2. news_tool ile Bitcoin haberlerini topla
3. sentiment_tool ile haberlerin duygu analizini yap
4. Sonu√ßlarƒ± detaylƒ± a√ßƒ±kla
5. decision_tool ile karar ver
6. plotting_tool ile grafik olu≈ütur

Kullanƒ±cƒ± mesajƒ±nƒ± analiz et ve uygun ara√ßlarƒ± kullan.""",
                ),
                MessagesPlaceholder(variable_name="chat_history"),
                ("human", "{input}"),
                MessagesPlaceholder(variable_name="agent_scratchpad"),
            ]
        )

        # Agent olu≈ütur
        self.agent = create_openai_tools_agent(
            llm=self.llm, tools=self.tools, prompt=self.prompt
        )

        # Agent executor
        self.agent_executor = AgentExecutor(
            agent=self.agent,
            tools=self.tools,
            memory=self.memory,
            verbose=True,
            handle_parsing_errors=True,
        )

    @tool("news_tool")
    async def news_tool(self, topic: str) -> str:
        """Belirtilen konu hakkƒ±nda g√ºncel haberleri toplar."""
        from app.agent.tools.news_tool import get_news

        try:
            news_data = await get_news(topic)

            # Haberleri formatla
            formatted_news = []
            for i, news in enumerate(news_data[:5], 1):  # ƒ∞lk 5 haberi g√∂ster
                formatted_news.append(f"{i}. {news.get('title', 'Ba≈ülƒ±k yok')}")
                if news.get("description"):
                    formatted_news.append(f"   {news.get('description', '')[:100]}...")
                formatted_news.append("")

            return f"üì∞ {topic} i√ßin {len(news_data)} haber bulundu:\n\n" + "\n".join(
                formatted_news
            )
        except Exception as e:
            return f"‚ùå Haber toplama hatasƒ±: {str(e)}"

    @tool("sentiment_tool")
    async def sentiment_tool(self, news_data: List[Dict]) -> str:
        """Haberlerin duygu analizini yapar."""
        from app.agent.tools.sentiment_tool import analyze_sentiments

        try:
            sentiments = await analyze_sentiments(news_data)

            # Sentiment sonu√ßlarƒ±nƒ± formatla
            positive_count = sum(
                1 for s in sentiments if s.get("sentiment_label") == "positive"
            )
            negative_count = sum(
                1 for s in sentiments if s.get("sentiment_label") == "negative"
            )
            neutral_count = sum(
                1 for s in sentiments if s.get("sentiment_label") == "neutral"
            )

            avg_score = (
                sum(s.get("sentiment_score", 0) for s in sentiments) / len(sentiments)
                if sentiments
                else 0
            )

            return f"""üìä Sentiment Analizi Sonu√ßlarƒ±:
            
üìà Pozitif Haberler: {positive_count}
üìâ Negatif Haberler: {negative_count}
‚û°Ô∏è N√∂tr Haberler: {neutral_count}
üìä Ortalama Sentiment Skoru: {avg_score:.3f}

Detaylƒ± Analiz:
{chr(10).join([f"‚Ä¢ {s.get('title', 'Ba≈ülƒ±k yok')[:50]}... - Skor: {s.get('sentiment_score', 0):.3f} ({s.get('sentiment_label', 'unknown')})" for s in sentiments[:3]])}"""
        except Exception as e:
            return f"‚ùå Sentiment analizi hatasƒ±: {str(e)}"

    @tool("decision_tool")
    async def decision_tool(self, sentiments: List[Dict]) -> Dict:
        """Sentiment skorlarƒ±na g√∂re alƒ±m-satƒ±m kararƒ± verir."""
        from app.agent.tools.decision_tool import make_trade_decision

        try:
            decision, confidence = await make_trade_decision(sentiments)
            return {
                "status": "success",
                "decision": decision,
                "confidence": confidence,
                "reasoning": self._generate_decision_reasoning(
                    sentiments, decision, confidence
                ),
            }
        except Exception as e:
            return {"status": "error", "error": str(e)}

    @tool("trading_tool")
    async def trading_tool(
        self, symbol: str, decision: str, amount: float = 0.001
    ) -> Dict:
        """Otomatik trading i≈ülemi yapar (sadece y√ºksek g√ºven seviyesinde)."""
        from app.agent.tools.trading_tool import execute_trade

        try:
            if decision.lower() == "hold":
                return {
                    "status": "no_action",
                    "message": "Hold kararƒ± - i≈ülem yapƒ±lmadƒ±",
                }

            trade_result = await execute_trade(symbol, decision, amount)
            return {"status": "success", "trade_result": trade_result}
        except Exception as e:
            return {"status": "error", "error": str(e)}

    @tool("plotting_tool")
    async def plotting_tool(self, topic: str, sentiments: List[Dict]) -> Dict:
        """Sentiment trend grafiƒüi olu≈üturur."""
        from app.agent.tools.plotting_tool import plot_sentiment_graph

        try:
            graph_url = await plot_sentiment_graph(topic, sentiments)
            return {"status": "success", "graph_url": graph_url, "topic": topic}
        except Exception as e:
            return {"status": "error", "error": str(e)}

    def _generate_decision_reasoning(
        self, sentiments: List[Dict], decision: str, confidence: float
    ) -> str:
        """Karar i√ßin gerek√ße olu≈üturur."""
        if not sentiments:
            return "Haber verisi bulunamadƒ±ƒüƒ± i√ßin HOLD kararƒ± verildi."

        avg_score = sum(item.get("sentiment_score", 0) for item in sentiments) / len(
            sentiments
        )
        positive_count = sum(
            1 for item in sentiments if item.get("sentiment_label") == "positive"
        )
        negative_count = sum(
            1 for item in sentiments if item.get("sentiment_label") == "negative"
        )

        reasoning = f"""
Analiz Sonu√ßlarƒ±:
- Ortalama Sentiment Skoru: {avg_score:.2f}
- Pozitif Haber Sayƒ±sƒ±: {positive_count}
- Negatif Haber Sayƒ±sƒ±: {negative_count}
- Toplam Haber Sayƒ±sƒ±: {len(sentiments)}

Karar: {decision.upper()}
G√ºven Seviyesi: %{confidence * 100:.1f}

Gerek√ße: {self._get_decision_explanation(decision, avg_score, positive_count, negative_count)}
"""
        return reasoning

    def _get_decision_explanation(
        self, decision: str, avg_score: float, positive: int, negative: int
    ) -> str:
        """Karar i√ßin detaylƒ± a√ßƒ±klama."""
        if decision == "buy":
            if positive > negative:
                return f"Pozitif haberler ({positive}) negatif haberlerden ({negative}) fazla. Ortalama sentiment skoru ({avg_score:.2f}) y√ºksek."
            else:
                return f"Sentiment skoru ({avg_score:.2f}) yeterince y√ºksek ve teknik analiz pozitif."

        elif decision == "sell":
            if negative > positive:
                return f"Negatif haberler ({negative}) pozitif haberlerden ({positive}) fazla. Ortalama sentiment skoru ({avg_score:.2f}) d√º≈ü√ºk."
            else:
                return f"Sentiment skoru ({avg_score:.2f}) d√º≈ü√ºk ve risk fakt√∂rleri y√ºksek."

        else:  # hold
            return f"Sentiment skoru ({avg_score:.2f}) n√∂tr b√∂lgede. Pozitif ({positive}) ve negatif ({negative}) haberler dengeli."

    async def process_message(self, message: str) -> Dict[str, Any]:
        """Kullanƒ±cƒ± mesajƒ±nƒ± AI agent ile i≈üler."""
        try:
            # Agent'ƒ± √ßalƒ±≈ütƒ±r
            result = await self.agent_executor.ainvoke({"input": message})

            # Haber verilerini manuel olarak topla (eƒüer Bitcoin ile ilgiliyse)
            news_data = []
            sentiment_data = []

            if "bitcoin" in message.lower():
                try:
                    from app.agent.tools.news_tool import get_news
                    from app.agent.tools.sentiment_tool import analyze_sentiments

                    news_data = await get_news("Bitcoin")
                    if news_data:
                        sentiment_data = await analyze_sentiments(news_data)
                except Exception as e:
                    print(f"Haber toplama hatasƒ±: {e}")

            return {
                "response": result["output"],
                "is_ai_agent": True,
                "tools_used": self._extract_tools_used(result),
                "news_data": news_data,
                "sentiment_data": sentiment_data,
            }

        except Exception as e:
            return {
                "error": f"AI Agent i≈ülemi sƒ±rasƒ±nda hata: {str(e)}",
                "is_ai_agent": True,
            }

    def _extract_tools_used(self, result: Dict) -> List[str]:
        """Kullanƒ±lan ara√ßlarƒ± √ßƒ±karƒ±r."""
        # Bu kƒ±sƒ±m LangChain'in tool usage tracking'i ile geli≈ütirilebilir
        return ["ai_agent"]


# Global agent instance
ai_agent = FinancialAgent()
